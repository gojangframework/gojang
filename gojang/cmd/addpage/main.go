package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

func main() {
	fmt.Println("ðŸš€ Gojang Static Page Generator")
	fmt.Println("==================================")
	fmt.Println()

	reader := bufio.NewReader(os.Stdin)

	// Get page name
	fmt.Print("Page name (e.g., 'About', 'Contact', 'Terms'): ")
	pageName, _ := reader.ReadString('\n')
	pageName = strings.TrimSpace(pageName)

	if pageName == "" {
		log.Fatal("âŒ Page name is required")
	}

	// Validate page name
	if !isValidPageName(pageName) {
		log.Fatal("âŒ Page name must contain only letters and spaces")
	}

	// Get page title
	fmt.Print("Page title (e.g., 'About Us', 'Contact Us'): ")
	pageTitle, _ := reader.ReadString('\n')
	pageTitle = strings.TrimSpace(pageTitle)

	if pageTitle == "" {
		pageTitle = pageName
	}

	// Get route path
	defaultRoute := "/" + strings.ToLower(strings.ReplaceAll(pageName, " ", "-"))
	fmt.Printf("Route path (default: %s): ", defaultRoute)
	routePath, _ := reader.ReadString('\n')
	routePath = strings.TrimSpace(routePath)

	if routePath == "" {
		routePath = defaultRoute
	}

	// Validate route path
	if !strings.HasPrefix(routePath, "/") {
		log.Fatal("âŒ Route path must start with /")
	}

	// Ask if page should be protected (require authentication)
	fmt.Print("Require authentication? (y/N): ")
	requireAuth, _ := reader.ReadString('\n')
	requireAuth = strings.TrimSpace(strings.ToLower(requireAuth))
	isProtected := requireAuth == "y" || requireAuth == "yes"

	// Determine paths
	projectRoot, err := findProjectRoot()
	if err != nil {
		log.Fatalf("âŒ Failed to find project root: %v", err)
	}

	templatePath := filepath.Join(projectRoot, "gojang", "views", "templates")
	handlerPath := filepath.Join(projectRoot, "gojang", "http", "handlers", "pages.go")
	routesPath := filepath.Join(projectRoot, "gojang", "http", "routes", "pages.go")

	// Generate template file name
	templateFileName := strings.ToLower(strings.ReplaceAll(pageName, " ", "-")) + ".html"
	templateFilePath := filepath.Join(templatePath, templateFileName)

	// Check if template already exists
	if _, err := os.Stat(templateFilePath); err == nil {
		log.Fatalf("âŒ Template file already exists: %s", templateFilePath)
	}

	// Create template file
	fmt.Println()
	fmt.Println("ðŸ“ Creating template file...")
	if err := createTemplateFile(templateFilePath, pageTitle, pageName); err != nil {
		log.Fatalf("âŒ Failed to create template file: %v", err)
	}
	fmt.Printf("âœ… Created: %s\n", templateFilePath)

	// Add handler to pages.go
	fmt.Println()
	fmt.Println("ðŸ”§ Adding handler to pages.go...")
	handlerFuncName := toPascalCase(pageName)
	if err := addHandler(handlerPath, handlerFuncName, pageTitle, templateFileName); err != nil {
		log.Fatalf("âŒ Failed to add handler: %v", err)
	}
	fmt.Printf("âœ… Added handler: %s\n", handlerFuncName)

	// Add route to pages.go
	fmt.Println()
	fmt.Println("ðŸ”— Adding route to pages.go...")
	if err := addRoute(routesPath, routePath, handlerFuncName, isProtected); err != nil {
		log.Fatalf("âŒ Failed to add route: %v", err)
	}
	fmt.Printf("âœ… Added route: %s -> %s\n", routePath, handlerFuncName)

	// Success message
	fmt.Println()
	fmt.Println("âœ¨ Static page created successfully!")
	fmt.Println()
	fmt.Println("Next steps:")
	fmt.Println("1. Restart your server: go run ./gojang/cmd/web")
	fmt.Printf("2. Visit: http://localhost:8080%s\n", routePath)
	fmt.Println("3. Edit the template to customize your page")
}

// isValidPageName checks if the page name contains only letters and spaces
func isValidPageName(name string) bool {
	matched, _ := regexp.MatchString(`^[A-Za-z\s]+$`, name)
	return matched
}

// toPascalCase converts a string to PascalCase (e.g., "About Us" -> "AboutUs")
func toPascalCase(s string) string {
	words := strings.Fields(s)
	for i, word := range words {
		words[i] = strings.Title(strings.ToLower(word))
	}
	return strings.Join(words, "")
}

// findProjectRoot finds the project root directory by looking for go.mod
func findProjectRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("could not find project root (go.mod not found)")
		}
		dir = parent
	}
}

// createTemplateFile creates the HTML template file
func createTemplateFile(path, title, pageName string) error {
	content := fmt.Sprintf(`{{define "title"}}%s{{end}}

{{define "content"}}
<div class="container">
    <h1>%s</h1>
    
    <div class="card">
        <p>
            Welcome to the %s page. This page was auto-generated by the Gojang static page generator.
        </p>
        
        <p>
            Edit this template at <code>%s</code> to customize the content.
        </p>
        
        <div class="alert alert-info" style="margin-top: 2rem;">
            <p>
                <strong>Tip:</strong> You can add HTMX attributes to make this page interactive!
            </p>
        </div>
    </div>
</div>
{{end}}
`, title, title, pageName, filepath.Base(path))

	return os.WriteFile(path, []byte(content), 0644)
}

// addHandler adds a handler method to pages.go
func addHandler(path, funcName, title, templateFileName string) error {
	// Read the file
	content, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	// Check if handler already exists
	if strings.Contains(string(content), fmt.Sprintf("func (h *PageHandler) %s(", funcName)) {
		return fmt.Errorf("handler %s already exists", funcName)
	}

	// Find the position to insert the handler (before NotFound)
	notFoundPos := strings.Index(string(content), "// NotFound renders the 404 page")
	if notFoundPos == -1 {
		// If NotFound is not found, append at the end
		notFoundPos = len(content)
	}

	// Create the handler code
	handlerCode := fmt.Sprintf("\n// %s renders the %s page\nfunc (h *PageHandler) %s(w http.ResponseWriter, r *http.Request) {\n\th.Renderer.Render(w, r, \"%s\", &renderers.TemplateData{\n\t\tTitle: \"%s\",\n\t\tData:  map[string]interface{}{},\n\t})\n}\n\n",
		funcName, strings.ToLower(funcName), funcName, templateFileName, title)

	// Insert the handler code
	newContent := string(content[:notFoundPos]) + handlerCode + string(content[notFoundPos:])

	// Write the file back
	return os.WriteFile(path, []byte(newContent), 0644)
}

// addRoute adds a route to pages.go
func addRoute(path, routePath, handlerFuncName string, isProtected bool) error {
	// Read the file
	content, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	// Check if route already exists
	if strings.Contains(string(content), fmt.Sprintf(`r.Get("%s"`, routePath)) ||
		strings.Contains(string(content), fmt.Sprintf(`auth.Get("%s"`, routePath)) {
		return fmt.Errorf("route %s already exists", routePath)
	}

	var newContent string

	if isProtected {
		// Find the position to insert the protected route
		// Look for the protected pages group
		protectedGroupPos := strings.Index(string(content), "// Protected pages")
		if protectedGroupPos == -1 {
			return fmt.Errorf("could not find protected pages section")
		}

		// Find the auth.Get("/dashboard" line
		dashboardPos := strings.Index(string(content[protectedGroupPos:]), `auth.Get("/dashboard"`)
		if dashboardPos == -1 {
			return fmt.Errorf("could not find dashboard route")
		}
		insertPos := protectedGroupPos + dashboardPos

		// Find the end of the line
		endOfLine := strings.Index(string(content[insertPos:]), "\n")
		insertPos += endOfLine + 1

		// Create the route code
		routeCode := fmt.Sprintf("\t\tauth.Get(\"%s\", handler.%s)\n", routePath, handlerFuncName)

		// Insert the route code
		newContent = string(content[:insertPos]) + routeCode + string(content[insertPos:])
	} else {
		// Find the position to insert the public route
		// Look for r.Get("/", handler.Home)
		homeRoutePos := strings.Index(string(content), `r.Get("/", handler.Home)`)
		if homeRoutePos == -1 {
			return fmt.Errorf("could not find home route")
		}

		// Find the end of the line
		endOfLine := strings.Index(string(content[homeRoutePos:]), "\n")
		insertPos := homeRoutePos + endOfLine + 1

		// Create the route code
		routeCode := fmt.Sprintf("\tr.Get(\"%s\", handler.%s)\n", routePath, handlerFuncName)

		// Insert the route code
		newContent = string(content[:insertPos]) + routeCode + string(content[insertPos:])
	}

	// Write the file back
	return os.WriteFile(path, []byte(newContent), 0644)
}
